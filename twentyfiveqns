/* codes contains my SQL queries for questions from https://towardsdatascience.com/twenty-five-sql-practice-exercises-5fc791e24082 
Language: MySQL */

///////* 1) Cancellation Rates - a query to return the publication and cancellation rate for each user *////////////
/* Step 1 - Create tables */
CREATE TABLE users (user_id INT, 
                    action VARCHAR(10), 
                    date DATE) ;

INSERT INTO users 
(user_id, action, date) 
VALUES (1,'start','01-01-20'),
(1,'cancel', ('01-02-20')),
(1,'cancel', ('01-02-20')), 
(2,'start', ('01-03-20')), 
(2,'publish', ('01-04-20')), 
(3,'start', ('01-05-20')), 
(3,'cancel', ('01-06-20')), 
(1,'start', ('01-07-20')), 
(1,'publish', ('01-08-20'));

/* Step 2 - Create output */ 
SELECT u.user_id, u.publish_count/u.start_count AS publish_rate, u.cancel_count/u.start_count AS cancel_rate
FROM (SELECT user_id, 
SUM(CASE WHEN action = 'start' THEN 1 ELSE 0 END) AS start_count,
SUM(CASE WHEN action = 'publish' THEN 1 ELSE 0 END) AS publish_count,
SUM(CASE WHEN action = 'cancel' THEN 1 ELSE 0 END) AS cancel_count
FROM users
GROUP BY user_id) AS u;

///////* 2) Changes in net worth - write a query to return the change in net worth for each user, ordered by decreasing net change. *////////////
/* Step 1 - Create tables */
CREATE TABLE transactions 
(sender INT, receiver INT, amount INT, date DATE) ;

INSERT INTO transactions 
(sender,receiver,amount,date) 
VALUES (5, 2, 10,'12-2-20'),
(1, 3, 15, '13-2-20'), 
(2, 1, 20,'13-2-20'), 
(2, 3, 25, '14-2-20'), 
(3, 1, 20, '15-2-20'), 
(3, 2, 15,'15-2-20'), 
(1, 4, 5, '16-2-20');

/* Step 2 - Create output */ 
/*complete in one query - 

SELECT r.receiver, r.income-r.outflow AS net_change FROM
(SELECT i.receiver, IFNULL(i.inflow,0) AS income, IFNULL(o.outflow,0) AS outflow
FROM (SELECT receiver, SUM(amount) AS inflow
FROM transactions
GROUP BY receiver) AS i
LEFT OUTER JOIN (SELECT sender, SUM(amount) AS outflow
FROM transactions
GROUP BY sender) AS o
ON i.receiver=o.sender

UNION

SELECT o.sender, IFNULL(i.inflow,0) AS income, IFNULL(o.outflow,0) AS outflow
FROM (SELECT receiver, SUM(amount) AS inflow
FROM transactions
GROUP BY receiver) AS i
RIGHT OUTER JOIN (SELECT sender, SUM(amount) AS outflow
FROM transactions
GROUP BY sender) AS o
ON i.receiver=o.sender) AS r
ORDER BY (net_change) DESC;


///////* 3) Most frequent items - write a query to return the most frequent item ordered on each date. Return multiple items in the case of a tie. *///
CREATE TABLE items 
(date DATE, item VARCHAR(20)) ;

INSERT INTO items 
(date,item) 
VALUES (('01-01-20'),'apple'), 
(('01-01-20'),'apple'), 
(('01-01-20' ),'pear'), 
(('01-01-20'),'pear'), 
(('01-02-20'),'pear'), 
(('01-02-20'),'pear'), 
(('01-02-20'),'pear'), 
(('01-02-20'),'orange');


CREATE TABLE temp AS (SELECT date,item, COUNT(*) AS count
FROM items
GROUP BY date, item);

CREATE TABLE temp1 AS (SELECT t.date, MAX(t.count) AS count
FROM temp AS t
GROUP BY date);

SELECT temp1.date, temp1.count, temp.item 
FROM temp1
JOIN temp
ON temp1.date=temp.date AND temp1.count=temp.count;


///////* 4) Time difference between latest actions- a query to return for each user the time elapsed between the last action and the second-to-last action, in ascending order by user ID *////////////

INSERT INTO user 
(user_id, action, date) 
VALUES (1, 'start', '20-2-12'), 
(1, 'cancel', '20-2-13'), 
(2, 'start', '20-2-11'), 
(2, 'publish', '20-2-14'), 
(3, 'start', '20-2-15'), 
(3, 'cancel', '20-2-15'), 
(4, 'start', '20-2-18'), 
(1, 'publish', '20-2-19' );

          
CREATE TABLE user2 AS
(SELECT *  FROM
(SELECT u.*, row_number() OVER(PARTITION BY user_id ORDER BY date DESC) AS seq
FROM user AS u) AS u1
HAVING u1.seq<3);

SELECT u4.user_id, u4.lagged_date-u4.date AS days_elapsed
FROM
(SELECT u3.*, LAG(date) OVER(PARTITION BY user_id ORDER BY date DESC) AS lagged_date
FROM user2 AS u3) AS u4
INNER JOIN (SELECT user2.user_id, MAX(user2.seq) AS seq
FROM user2
GROUP BY user2.user_id) AS u5
ON u5.user_id = u4.user_id AND u5.seq=u4.seq
;

///////* 5)  Super users - A company defines its super users as those who have made at least two transactions.
write a query to return, for each user, the date when they become a super user, ordered by oldest super users first. 
Users who are not super users should also be present in the table.
*////////////

CREATE TABLE superuser 
(user_id INT, product_id INT, date DATE) ;

INSERT INTO superuser 
(user_id, product_id, date) 
VALUES (1, 101, '20-2-12'), 
(2, 105, '20-2-13-20'), 
(1, 111, '20-2-14-20' ), 
(3, 121, '20-2-15-20'), 
(1, 101, '20-2-16-20'), 
(2, 105, '20-2-17-20' ),
(4, 101, '20-2-16-20'), 
(3, 105, '20-2-15-20');


SELECT su1.user_id, su1.superuser_date FROM
(SELECT su.user_id, su.times, 
CASE WHEN su.times>=2 AND su.times1=2 THEN su.date ELSE NULL END AS superuser_date
FROM (SELECT superuser.*, COUNT(*) OVER(PARTITION BY user_id) AS times, 
      row_number() OVER(PARTITION BY user_id ORDER BY date) AS times1
FROM superuser) AS su) AS su1
WHERE (su1.superuser_date IS NOT NULL AND su1.times>=2) OR 
(su1.superuser_date IS NULL AND su1.times<2)
ORDER BY su1.superuser_date;

///////* 6)  Content recommendation (hard) - Using the following two tables, 
write a query to return page recommendations to a social media user based on the pages that their friends have liked, 
but that they have not yet marked as liked. Order the result by ascending user ID
*////////////
CREATE TABLE friends 
(user_id INT, friend INT) ;

INSERT INTO friends 
(user_id, friend) 
VALUES(1, 2), (1, 3), (1, 4), (2, 1), (3, 1), (3, 4), (4, 1), (4, 3);

CREATE TABLE likes 
(user_id INT, page_likes VARCHAR(1)) ;

INSERT INTO likes 
(user_id, page_likes) 
VALUES(1, 'A'), (1, 'B'), (1, 'C'), (2, 'A'), (3, 'B'), (3, 'C'), (4, 'B');

SELECT DISTINCT f2.user_id, f2.page_likes AS recommended_page FROM 
(SELECT *
FROM 
(SELECT f.friend, f.user_id, l.page_likes
FROM friends AS f
INNER JOIN likes AS l
ON f.friend = l.user_id) AS f1
WHERE NOT EXISTS (SELECT * FROM likes AS l1
                 WHERE l1.user_id=f1.user_id AND l1.page_likes=f1.page_likes)) AS f2;

///////* 7)  Mobile and web visitors - With the following two tables, return the fraction of users who only visited mobile, only visited web, and visited both. */////


